*surround-funk.txt* (v2.0.0) Delete, change and yank a surrounding function
call along with its additional arguments. Then 'grip' a text object or motion
with the surrounding function call.

License: Same terms as Vim itself (see |license|)

This plugin is only available if 'compatible' is not set.


SURROUND-FUNK                                   *surround-funk* *funk*

This was inspired by tpope's |surround| plugin and allows you to delete, change
and yank a surrounding function call along with its additional arguments. With
the surrounding function call in the unnamed register, you can 'grip' a word or
another function call with it. 'Gripping' will wrap/encompass a word or
function call with the one you have in the unnamed register (see below).


TABLE OF CONTENTS

1. Usage                                                            |funk1|
    1.1 What is a surrounding function call?                        |funk1.1|
    1.2 Deleting, changing and yanking a surrounding function call  |funk1.2|
    1.3 Text objects                                                |funk1.3|
    1.4 Gripping a text object or motion with a function call       |funk1.4|
    1.5 Settings                                                    |funk1.5|
        1.5.1 Prevent automatic creation of mappings                |funk1.5.1|
        1.5.2 Specify characters allowed in a function name         |funk1.5.2|
2. Contribution guidelines                                          |funk2|
    2.1 Report a bug                                                |funk2.1|
    2.2 Request a feature                                           |funk2.2|
3. Todo list                                                        |funk3|
    3.1 Major                                                       |funk3.1|
    3.2 Minor                                                       |funk3.2|
    3.3 Patches                                                     |funk3.3|
    3.4 Bugs                                                        |funk3.4|
4. Related plugins                                                  |funk4|


USAGE                                                                   *funk1*


WHAT IS A SURROUNDING FUNCTION CALL?                                  *funk1.1*

Below, the * symbols show what would be deleted (or yanked) with the dsf (or
ysf) command. The ^ symbols show where the cursor can be when issuing the
command:


sf                      Where the name of the function (e.g. outerfunc) is a 
                        standard Vim |word|.

                           **********               *
                        np.outerfunc(innerfunc(arg1))
                           ^^^^^^^^^^               ^
  
                           **********               *************
                        np.outerfunc(innerfunc(arg1), arg2, arg3)
                           ^^^^^^^^^^               ^^^^^^^^^^^^^
  
                           **********    *
                        np.outerfunc(arg1)
                           ^^^^^^^^^^^^^^^
  
                           **********                *
                        np.outerfunc(arg1, arg2, arg3)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
                        multi-line functions also work:

                           **********               ***************
                        np.outerfunc(innerfunc(arg1),   
 cursor anywhere here >                                 arg2, arg3) 
                           ^^^^^^^^^^               ^^^^^^^^^^^^^^^


sF                      Where the name of the function (e.g. np.outerfunc) is 
                        any contiguous sequence of characters in
                        |g:surround_funk_legal_func_name_chars|

                        *************               *
                        np.outerfunc(innerfunc(arg1))
                        ^^^^^^^^^^^^^               ^

                        *************               *************
                        np.outerfunc(innerfunc(arg1), arg2, arg3)
                        ^^^^^^^^^^^^^               ^^^^^^^^^^^^^

                        *************    *
                        np.outerfunc(arg1)
                        ^^^^^^^^^^^^^^^^^^
  
                        *************                *
                        np.outerfunc(arg1, arg2, arg3)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
                        multi-line function calls also work:

                        *************               ***************
                        np.outerfunc(innerfunc(arg1),   
 cursor anywhere here >                                 arg2, arg3) 
                        ^^^^^^^^^^^^^               ^^^^^^^^^^^^^^^


DELETING, CHANGING AND YANKING A SURROUNDING FUNCTION CALL            *funk1.2*

If you have tpope's excellent repeat.vim plugin, then the dsf and dsF commands
are repeatable with the dot command (see |single-repeat|).

To prevent these mappings from being generated, and define your own custom
ones, see |g:surround_funk_create_mappings| below.

                                        *surround-funk#dsf*
dsf                     Delete surrounding function call

                                        *surround-funk#dsF*
dsF                     Like dsf, but the function name is delimited by any
                        character not in
                        |g:surround_funk_legal_func_name_chars|

                                        *surround-funk#csf*
csf                     Like dsf but start instert mode where the opening
                        parenthesis of the changed function call used to be.

                                        *surround-funk#csF*
csF                     Like csf, but the function name is delimited by any
                        character not in
                        |g:surround_funk_legal_func_name_chars|

                                        *surround-funk#ysf*
ysf                     Yank surrounding function call

                                        *surround-funk#ysF*
ysF                     Like ysf, but the function name is delimited by any
                        character not in
                        |g:surround_funk_legal_func_name_chars|


TEXT OBJECTS                                                          *funk1.3*

The following text objects are made available by |surround-funk|:

To prevent these mappings from being generated, and define your own, see
|g:surround_funk_create_mappings| below.

                                        *surround-funk#af*
af                      From the first letter of the function's name to the
                        closing parenthesis of that function call

                                        *surround-funk#aF*
aF                      Like af, but the function name is delimited by any
                        character not in
                        |g:surround_funk_legal_func_name_chars|

                                        *surround-funk#if*  
if                      Alias of af

                                        *surround-funk#iF*  
iF                      Alias of aF

                                        *surround-funk#an*  
an                      The function's name

                                        *surround-funk#aN*  
aN                      Like an, but the function name is delimited by any
                        character not in
                        |g:surround_funk_legal_func_name_chars|

                                        *surround-funk#in*  
in                      Alias of an

                                        *surround-funk#iN*  
iN                      Alias of aN



For example, with the cursor anywhere indicated by the ^ symbols, doing |vif|
will visually select the entire function call, indicated by the * symbols (to
include the 'np.' part of the function's name, use |viF|):

       **************************************
    np.outerfunc(innerfunc(arg1), arg2, arg3)
       ^^^^^^^^^^               ^^^^^^^^^^^^^


To select just the function's name, use |vin| (again, use |viN| to include the
'np.' part):

       *********
    np.outerfunc(innerfunc(arg1), arg2, arg3)
       ^^^^^^^^^^               ^^^^^^^^^^^^^


GRIPPING A TEXT OBJECT OR MOTION WITH A FUNCTION CALL                 *funk1.4*

If you have tpope's excellent repeat.vim plugin, then the following command is
repeatable with the dot command (see |single-repeat|).

To prevent this mapping from being generated, and define your own, see
|g:surround_funk_create_mappings| below.

                                        *surround-funk#gs*
gs                     Grip (i.e wrap/encompass) any text object or motion with
                       with the function call in the unnamed register.


In the example below, with the cursor anywhere with a ^ symbol, you can do ysF
to 'yank the surrounding function call' (which is all the stuff with * above
it):

    *************               *************
    np.outerfunc(innerfunc(arg1), arg2, arg3)
    ^^^^^^^^^^^^^               ^^^^^^^^^^^^^


Then go to some other function call (or just a word) (the cursor can be
anywhere in this case):

    os.lonelyfunc(argA, argB)
    ^^^^^^^^^^^^^^^^^^^^^^^^^


And do gsiF or gsaF to 'grip/surround' the lonely function call with the yanked
one:

    *************                         *************
    np.outerfunc(os.lonelyfunc(argA, argB), arg2, arg3)
    ^


You could then move to a word:

    MeNext
    ^^^^^^


and grip/surround it with gsiw:

    *************      *************
    np.outerfunc(MeNext, arg2, arg3)
    ^


You could also grip a multi-line function call (again using gsiF or gsaF):

    **************      *******
    os.multi_line(argA(),
                    argB, argC) < anywhere on this line is fine too
    ^^^^^^^^^^^^^^  ^^^^^^^^^^^


To get:

    *************                    *
    np.outerfunc(os.multi_line(argA(),
                    argB, argC), arg2, arg3)
                               *************


SETTINGS                                                              *funk1.5*

PREVENT AUTOMATIC CREATION OF MAPPINGS                              *funk1.5.1*

                                   *g:surround_funk_create_mappings*
By default |surround-funk| creates the above mappings. If you would rather it
didn't do this (for instance if you already have those key combinations mapped
to something else) you can turn them off with:

    let g:surround_funk_create_mappings = 0

And map them to something different with:

    nmap <your-map-here> <Plug>(<OperationToMap>)

For reference, the default mappings are as follows:

    " normal mode
    nmap <silent> dsf <Plug>(DeleteSurroundingFunction)
    nmap <silent> dsF <Plug>(DeleteSurroundingFUNCTION)
    nmap <silent> csf <Plug>(ChangeSurroundingFunction)
    nmap <silent> csF <Plug>(ChangeSurroundingFUNCTION)
    nmap <silent> ysf <Plug>(YankSurroundingFunction)
    nmap <silent> ysF <Plug>(YankSurroundingFUNCTION)

    " visual mode
    xmap <silent> af <Plug>(SelectWholeFunction)
    omap <silent> af <Plug>(SelectWholeFunction)
    xmap <silent> aF <Plug>(SelectWholeFUNCTION)
    omap <silent> aF <Plug>(SelectWholeFUNCTION)
    xmap <silent> if <Plug>(SelectWholeFunction)
    omap <silent> if <Plug>(SelectWholeFunction)
    xmap <silent> iF <Plug>(SelectWholeFUNCTION)
    omap <silent> iF <Plug>(SelectWholeFUNCTION)
    xmap <silent> an <Plug>(SelectFunctionName)
    omap <silent> an <Plug>(SelectFunctionName)
    xmap <silent> aN <Plug>(SelectFunctionNAME)
    omap <silent> aN <Plug>(SelectFunctionNAME)
    xmap <silent> in <Plug>(SelectFunctionName)
    omap <silent> in <Plug>(SelectFunctionName)
    xmap <silent> iN <Plug>(SelectFunctionNAME)
    omap <silent> iN <Plug>(SelectFunctionNAME)

    " operator pending mode
    nmap <silent> gs <Plug>(GripSurroundObject)
    vmap <silent> gs <Plug>(GripSurroundObject)

N.B. If you're worried about remapping the core vim command |gs|, done't be -
it literally does nothing.


SPECIFY CHARACTERS ALLOWED IN A FUNCTION NAME                       *funk1.5.2*

                                *g:surround_funk_legal_func_name_chars*
By default the |surround-funk| plugin defines any vim word character
([0-9A-Za-z_]) and any period symbols as valid parts of a function's name.
These characters are used to find the function name when using the capitalised
(e.g. |dsF|, but not |dsf|) versions of the above commands. You can add to, or
remove from, these groups.

The default:

g:surround_funk_legal_func_name_chars = ['[0-9]', '[A-Z]', '[a-z]', '_', '\.']


    will match function names like:

          *********  *************  **************
    ...), pd.mean(), np2.my_func(), 8np.my._func(), ...
          ^^^^^^^^^  ^^^^^^^^^^^^^  ^^^^^^^^^^^^^^


    but would stop at characters not in the legal name set (e.g. @, #, /):

             ******         ******      **********
    ...), pd@mean(), np2.my#func(), 8np/my._func(), ...
             ^^^^^^         ^^^^^^      ^^^^^^^^^^


To make numbers illegal, and to introduce # and @ as legal characters, use:

g:surround_funk_legal_func_name_chars = ['[A-Z]', '[a-z]', '_', '\.', '#', '@']


    will match function names like:

          *********     **********   *************
    ...), pd.mean(), np2.my_func(), 8np.my._func(), ...
          ^^^^^^^^^     ^^^^^^^^^^   ^^^^^^^^^^^^^

          *********     **********      **********
    ...), pd@mean(), np2.my#func(), 8np/my._func(), ...
          ^^^^^^^^^     ^^^^^^^^^^      ^^^^^^^^^^



CONTRIBUTION GUIDELINES                                                 *funk2*


REPORT A BUG                                                          *funk2.1*

First, check if the bug is already known by seeing whether it's listed on the
surround-funk todo list (jump there: |funk3|).

If it's not there, then please raise a new issue (or submit a pull request) on
github so I can fix it. To make it easier, you can use the following template
(If multi-line was broken, you could show me something like this):


    Command used: `dsF`

    Reproducible example (with arrows showing where the cursor was, in this case,
    the 'e' in 'mean'):

    np.mean(st.std(arg1),     <---
              arg2, arg3)

      ^
      |

    Result:

    np.mean(st.std(arg1),     <---
      arg2, ar

    ^
    |

    Expected:

    st.std(arg1)  <---
              
    ^
    |



REQUEST A FEATURE                                                     *funk2.2*

First, check if the feature is already planned by looking at the 
surround-funk todo list (jump there: |funk3|).

If it's not there, then please raise a new issue describing what you would like
and I'll see what I can do! If you would like to submit a pull request, then do
so (please let me know this is your plan first in a new issue).


TODO LIST                                                               *funk3*


MAJOR                                                                 *funk3.1*

- [x] Integrate with repeat.vim
- [x] Have `gs` commands operate on any motion (constrained to a single line?)


MINOR                                                                 *funk3.2*

- [x] Rewrite so we don't rely on tons of `exe norm!` commands
- [x] Fix big bug 1
- [x] Let users provide a list of legal function name characters
- [x] Allow users to define their own maps
- [x] Allow multi-line functions
- [x] Add `daf` and `dif` text objects
- [x] Add `dan` and `din` text object for the function name(?)
- [x] Allow yanking into a named register
- [ ] Some languages (e.g. Miranda family) don't use parentheses for function
      calls... I wonder if I could broaden the plugin to work on those too?


PATCHES                                                               *funk3.3*

- [x] Fix small bug 1


BUGS                                                                  *funk3.4*
                                                                         
Big Bugs                                                            
1. `gs` commands mess up sometimes: see testing.vim                 

Small Bugs                                                          
1. `ysf` and `ysF` remove a line above if applied to function on last line of
   file 


RELATED PLUGINS                                                         *funk4*

|surround| is a plugin is a tool for dealing with pairs of "surroundings."

|sandwich| is a set of operator and textobject plugins to add/delete/replace
           surroundings of a sandwiched textobject, like (foo), "bar".

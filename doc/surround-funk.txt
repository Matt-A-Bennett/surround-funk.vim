*surround-funk.txt* (v2.1.3) Delete, change and yank a surrounding function
call along with its additional arguments. Then 'grip' a text object or motion
with the surrounding function call.

License: Same terms as Vim itself (see |license|)

This plugin is only available if 'compatible' is not set.


SURROUND-FUNK                                   *surround-funk* *funk*

This was inspired by tpope's |surround| plugin and allows you to delete, change
and yank a surrounding function call along with its additional arguments. With
the surrounding function call in the unnamed register, you can 'grip' a word or
another function call with it. 'Gripping' will wrap/encompass a word or
function call with the one you have in the unnamed register (see below).


TABLE OF CONTENTS

1. Usage                                                            |funk1|
    1.1 What is a surrounding function call?                        |funk1.1|
    1.2 Deleting, changing and yanking a surrounding function call  |funk1.2|
    1.3 Text objects                                                |funk1.3|
    1.4 Gripping a text object or motion with a function call       |funk1.4|
        1.4.1 Gripping with function call in unnamed register       |funk1.4.1|
        1.4.2 Gripping with a new function call                     |funk1.4.2|
    1.5 Settings                                                    |funk1.5|
        1.5.1 Prevent automatic creation of mappings                |funk1.5.1|
        1.5.2 Specify characters allowed in a function name         |funk1.5.2|
2. Contribution guidelines                                          |funk2|
    2.1 Report a bug                                                |funk2.1|
    2.2 Request a feature                                           |funk2.2|
3. Related plugins                                                  |funk3|


USAGE                                                                   *funk1*


WHAT IS A SURROUNDING FUNCTION CALL?                                  *funk1.1*

Below, the * symbols show what would be deleted (or yanked) with the dsf (or
ysf) command. The ^ symbols show where the cursor can be when issuing the
command:


sf                      Where the name of the function (e.g. outerfunc) is a 
                        standard Vim |word|.

                           **********               *
                        np.outerfunc(innerfunc(arg1))
                           ^^^^^^^^^^               ^
  
                           **********               *************
                        np.outerfunc(innerfunc(arg1), arg2, arg3)
                           ^^^^^^^^^^               ^^^^^^^^^^^^^
  
                           **********    *
                        np.outerfunc(arg1)
                           ^^^^^^^^^^^^^^^
  
                           **********                *
                        np.outerfunc(arg1, arg2, arg3)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
                        multi-line functions also work:

                           **********               ***************
                        np.outerfunc(innerfunc(arg1),   
 cursor anywhere here >                                 arg2, arg3) 
                           ^^^^^^^^^^               ^^^^^^^^^^^^^^^


sF                      Where the name of the function (e.g. np.outerfunc) is 
                        any contiguous sequence of characters in
                        |g:surround_funk_legal_func_name_chars|

                        *************               *
                        np.outerfunc(innerfunc(arg1))
                        ^^^^^^^^^^^^^               ^

                        *************               *************
                        np.outerfunc(innerfunc(arg1), arg2, arg3)
                        ^^^^^^^^^^^^^               ^^^^^^^^^^^^^

                        *************    *
                        np.outerfunc(arg1)
                        ^^^^^^^^^^^^^^^^^^
  
                        *************                *
                        np.outerfunc(arg1, arg2, arg3)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
                        multi-line function calls also work:

                        *************               ***************
                        np.outerfunc(innerfunc(arg1),   
 cursor anywhere here >                                 arg2, arg3) 
                        ^^^^^^^^^^^^^               ^^^^^^^^^^^^^^^


DELETING, CHANGING AND YANKING A SURROUNDING FUNCTION CALL            *funk1.2*

If you have tpope's excellent repeat.vim plugin, then the dsf and dsF commands
are repeatable with the dot command (see |single-repeat|).

To prevent these mappings from being generated, and define your own custom
ones, see |g:surround_funk_create_mappings| below.

                                        *surround-funk#dsf*
dsf                     Delete surrounding function call

                                        *surround-funk#dsF*
dsF                     Like dsf, but the function name is delimited by any
                        character not in
                        |g:surround_funk_legal_func_name_chars|

                                        *surround-funk#csf*
csf                     Like dsf but start instert mode where the opening
                        parenthesis of the changed function call used to be.

                                        *surround-funk#csF*
csF                     Like csf, but the function name is delimited by any
                        character not in
                        |g:surround_funk_legal_func_name_chars|

                                        *surround-funk#ysf*
ysf                     Yank surrounding function call

                                        *surround-funk#ysF*
ysF                     Like ysf, but the function name is delimited by any
                        character not in
                        |g:surround_funk_legal_func_name_chars|


TEXT OBJECTS                                                          *funk1.3*

The following text objects are made available by |surround-funk|:

To prevent these mappings from being generated, and define your own, see
|g:surround_funk_create_mappings| below.

                                        *surround-funk#af*
af                      From the first letter of the function's name to the
                        closing parenthesis of that function call

                                        *surround-funk#aF*
aF                      Like af, but the function name is delimited by any
                        character not in
                        |g:surround_funk_legal_func_name_chars|

                                        *surround-funk#if*  
if                      Alias of af

                                        *surround-funk#iF*  
iF                      Alias of aF

                                        *surround-funk#an*  
an                      The function's name

                                        *surround-funk#aN*  
aN                      Like an, but the function name is delimited by any
                        character not in
                        |g:surround_funk_legal_func_name_chars|

                                        *surround-funk#in*  
in                      Alias of an

                                        *surround-funk#iN*  
iN                      Alias of aN



For example, with the cursor anywhere indicated by the ^ symbols, doing |vif|
will visually select the entire function call, indicated by the * symbols (to
include the 'np.' part of the function's name, use |viF|):

       **************************************
    np.outerfunc(innerfunc(arg1), arg2, arg3)
       ^^^^^^^^^^               ^^^^^^^^^^^^^


To select just the function's name, use |vin| (again, use |viN| to include the
'np.' part):

       *********
    np.outerfunc(innerfunc(arg1), arg2, arg3)
       ^^^^^^^^^^               ^^^^^^^^^^^^^


GRIPPING A TEXT OBJECT OR MOTION WITH A FUNCTION CALL                 *funk1.4*

GRIPPING WITH FUNCTION CALL IN UNNAMED REGISTER                     *funk1.4.1*

If you have tpope's excellent repeat.vim plugin, then the following command is
repeatable with the dot command (see |single-repeat|).

To prevent this mapping from being generated, and define your own, see
|g:surround_funk_create_mappings| below.

                                        *surround-funk#gs*
gs                     Grip (i.e wrap/encompass) any text object or motion with
                       with the function call in the unnamed register.


In the example below, with the cursor anywhere with a ^ symbol, you can do ysF
to 'yank the surrounding function call' (which is all the stuff with * above
it):

    *************               *************
    np.outerfunc(innerfunc(arg1), arg2, arg3)
    ^^^^^^^^^^^^^               ^^^^^^^^^^^^^


Then go to some other function call (or just a word) (the cursor can be
anywhere in this case):

    os.lonelyfunc(argA, argB)
    ^^^^^^^^^^^^^^^^^^^^^^^^^


And do gsiF or gsaF to 'grip/surround' the lonely function call with the yanked
one:

    *************                         *************
    np.outerfunc(os.lonelyfunc(argA, argB), arg2, arg3)
    ^


You could then move to a word:

    MeNext
    ^^^^^^


and grip/surround it with gsiw:

    *************      *************
    np.outerfunc(MeNext, arg2, arg3)
    ^


You could also grip a multi-line function call (again using gsiF or gsaF):

    **************      *******
    os.multi_line(argA(),
                    argB, argC) < anywhere on this line is fine too
    ^^^^^^^^^^^^^^  ^^^^^^^^^^^


To get:

    *************                    *
    np.outerfunc(os.multi_line(argA(),
                    argB, argC), arg2, arg3)
                               *************


GRIPPING WITH A NEW FUNCTION CALL                                   *funk1.4.2*

This one is pretty much the same as tpope's |surround| 'ys<textobject>f'
command: If gS is used, Vim prompts for a function name to insert. The target
text will be wrapped in a function call. This command differs from the
|surround| plugin in that after wrapping the target text, you are left in
insert mode just before the closing parenthesis (in case you want to start
adding trailing arguments).

                                        *surround-funk#gS*
gS                     Grip (i.e wrap/encompass) any text object or motion with
                       with a function call to be specified on the command line


For example, doing gSaF on this line:

    os.lonelyfunc(argA, argB)
    ^^^^^^^^^^^^^^^^^^^^^^^^^


and entering 'np.mean' at the prompt will yield the following with the cursor
(in insert mode) indicated by the ^ symbol:

    ********                         *
    np.mean(os.lonelyfunc(argA, argB))
                                     ^


SETTINGS                                                              *funk1.5*

PREVENT AUTOMATIC CREATION OF MAPPINGS                              *funk1.5.1*

                                   *g:surround_funk_create_mappings*
By default |surround-funk| creates the above mappings. If you would rather it
didn't do this (for instance if you already have those key combinations mapped
to something else) you can turn them off with:

    let g:surround_funk_create_mappings = 0

And map them to something different with:

    nmap <your-map-here> <Plug>(<OperationToMap>)

For reference, the default mappings are as follows:

    " normal mode
    nmap <silent> dsf <Plug>(DeleteSurroundingFunction)
    nmap <silent> dsF <Plug>(DeleteSurroundingFUNCTION)
    nmap <silent> csf <Plug>(ChangeSurroundingFunction)
    nmap <silent> csF <Plug>(ChangeSurroundingFUNCTION)
    nmap <silent> ysf <Plug>(YankSurroundingFunction)
    nmap <silent> ysF <Plug>(YankSurroundingFUNCTION)

    " visual mode
    xmap <silent> af <Plug>(SelectWholeFunction)
    omap <silent> af <Plug>(SelectWholeFunction)
    xmap <silent> aF <Plug>(SelectWholeFUNCTION)
    omap <silent> aF <Plug>(SelectWholeFUNCTION)
    xmap <silent> if <Plug>(SelectWholeFunction)
    omap <silent> if <Plug>(SelectWholeFunction)
    xmap <silent> iF <Plug>(SelectWholeFUNCTION)
    omap <silent> iF <Plug>(SelectWholeFUNCTION)
    xmap <silent> an <Plug>(SelectFunctionName)
    omap <silent> an <Plug>(SelectFunctionName)
    xmap <silent> aN <Plug>(SelectFunctionNAME)
    omap <silent> aN <Plug>(SelectFunctionNAME)
    xmap <silent> in <Plug>(SelectFunctionName)
    omap <silent> in <Plug>(SelectFunctionName)
    xmap <silent> iN <Plug>(SelectFunctionNAME)
    omap <silent> iN <Plug>(SelectFunctionNAME)

    " operator pending mode
    nmap <silent> gs <Plug>(GripSurroundObject)
    vmap <silent> gs <Plug>(GripSurroundObject)
    nmap <silent> gS <Plug>(GripSurroundObjectNoPaste)
    vmap <silent> gS <Plug>(GripSurroundObjectNoPaste)

N.B. If you're worried about remapping the core vim command |gs|, done't be -
it literally does nothing.


SPECIFY CHARACTERS ALLOWED IN A FUNCTION NAME                       *funk1.5.2*

                                *g:surround_funk_legal_func_name_chars*
By default the |surround-funk| plugin defines any vim word character
([0-9A-Za-z_]) and any period symbols as valid parts of a function's name.
These characters are used to find the function name when using the capitalised
(e.g. |dsF|, but not |dsf|) versions of the above commands. You can add to, or
remove from, these groups.

The default:

g:surround_funk_legal_func_name_chars = ['[0-9]', '[A-Z]', '[a-z]', '_', '\.']


    will match function names like:

          *********  *************  **************
    ...), pd.mean(), np2.my_func(), 8np.my._func(), ...
          ^^^^^^^^^  ^^^^^^^^^^^^^  ^^^^^^^^^^^^^^


    but would stop at characters not in the legal name set (e.g. @, #, /):

             ******         ******      **********
    ...), pd@mean(), np2.my#func(), 8np/my._func(), ...
             ^^^^^^         ^^^^^^      ^^^^^^^^^^


To make numbers illegal, and to introduce # and @ as legal characters, use:

g:surround_funk_legal_func_name_chars = ['[A-Z]', '[a-z]', '_', '\.', '#', '@']


    will match function names like:

          *********     **********   *************
    ...), pd.mean(), np2.my_func(), 8np.my._func(), ...
          ^^^^^^^^^     ^^^^^^^^^^   ^^^^^^^^^^^^^

          *********     **********      **********
    ...), pd@mean(), np2.my#func(), 8np/my._func(), ...
          ^^^^^^^^^     ^^^^^^^^^^      ^^^^^^^^^^


RELATED PLUGINS                                                         *funk3*

|surround| is a plugin is a tool for dealing with pairs of "surroundings."

|sandwich| is a set of operator and textobject plugins to add/delete/replace
           surroundings of a sandwiched textobject, like (foo), "bar".

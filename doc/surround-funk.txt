*surround-funk.txt* (v2.0.0) Delete, change and yank a surrounding function
call along with its additional arguments. Then 'grip' a word or function call
with the surrounding function call.

License: Same terms as Vim itself (see |license|)

This plugin is only available if 'compatible' is not set.


INTRODUCTION                                    *surround-funk*

This was inspired by tpope's |surround| plugin and allows you to delete, change
and yank a surrounding function call along with its additional arguments. With
the surrounding function call in the unnamed register, you can 'grip' a word or
another function call with it. 'Gripping' will wrap/encompass a word or
function call with the one you have in the unnamed register (see below).


USAGE


WHAT IS A SURROUNDING FUNCTION CALL?

Below, the * symbols show what would be deleted (or yanked) with the dsf (or
ysf) command. The ^ symbols show where the cursor can be when issuing the
command:


sf                      Where the name of the function (e.g. outerfunc) is a 
                        standard Vim |word|.

                           **********               *
                        np.outerfunc(innerfunc(arg1))
                           ^^^^^^^^^^               ^
  
                           **********               *************
                        np.outerfunc(innerfunc(arg1), arg2, arg3)
                           ^^^^^^^^^^               ^^^^^^^^^^^^^
  
                           **********    *
                        np.outerfunc(arg1)
                           ^^^^^^^^^^^^^^^
  
                           **********                *
                        np.outerfunc(arg1, arg2, arg3)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
                        multi-line functions also work:

                           **********               ***************
                        np.outerfunc(innerfunc(arg1),   
 cursor anywhere here >                                 arg2, arg3) 
                           ^^^^^^^^^^               ^^^^^^^^^^^^^^^


sF                      Where the name of the function (e.g. np.outerfunc) is 
                        any contiguous sequence of characters in
                        |g:surround_funk_legal_func_name_chars|

                        *************               *
                        np.outerfunc(innerfunc(arg1))
                        ^^^^^^^^^^^^^               ^

                        *************               *************
                        np.outerfunc(innerfunc(arg1), arg2, arg3)
                        ^^^^^^^^^^^^^               ^^^^^^^^^^^^^

                        *************    *
                        np.outerfunc(arg1)
                        ^^^^^^^^^^^^^^^^^^
  
                        *************                *
                        np.outerfunc(arg1, arg2, arg3)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  
                        multi-line function calls also work:

                        *************               ***************
                        np.outerfunc(innerfunc(arg1),   
 cursor anywhere here >                                 arg2, arg3) 
                        ^^^^^^^^^^^^^               ^^^^^^^^^^^^^^^


DELETING, CHANGING AND YANKING A SURROUNDING FUNCTION CALL

If you have tpope's excellent repeat.vim plugin, then the dsf and dsF commands
are repeatable with the dot command (see |single-repeat|).

To prevent these mappings from being generated, and define your own custom
ones, see |g:surround_funk_create_mappings| below.

                                        *surround-funk#dsf*
dsf                     Delete surrounding function call

                                        *surround-funk#dsF*
dsF                     Like dsf, but the function name is delimited by any
                        character not in
                        |g:surround_funk_legal_func_name_chars|

                                        *surround-funk#csf*
csf                     Like dsf but start instert mode where the opening
                        parenthesis of the changed function call used to be.

                                        *surround-funk#csF*
csF                     Like csf, but the function name is delimited by any
                        character not in
                        |g:surround_funk_legal_func_name_chars|

                                        *surround-funk#ysf*
ysf                     Yank surrounding function call

                                        *surround-funk#ysF*
ysF                     Like ysf, but the function name is delimited by any
                        character not in
                        |g:surround_funk_legal_func_name_chars|


TEXT OBJECTS

The following text objects are made available by |surround-funk|:

To prevent these mappings from being generated, and define your own, see
|g:surround_funk_create_mappings| below.

                                        *surround-funk#af*
af                      From the first letter of the function's name to the
                        closing parenthesis of that function call

                                        *surround-funk#aF*
aF                      Like af, but the function name is delimited by any
                        character not in
                        |g:surround_funk_legal_func_name_chars|

                                        *surround-funk#if*  
if                      Alias of af

                                        *surround-funk#iF*  
iF                      Alias of aF

                                        *surround-funk#an*  
an                      The function's name

                                        *surround-funk#aN*  
aN                      Like an, but the function name is delimited by any
                        character not in
                        |g:surround_funk_legal_func_name_chars|

                                        *surround-funk#in*  
in                      Alias of an

                                        *surround-funk#iN*  
iN                      Alias of aN



For example, with the cursor anywhere indicated by the ^ symbols, doing |vif|
will visually select the entire function call, indicated by the * symbols (to
include the 'np.' part of the function's name, use |viF|):

       **************************************
    np.outerfunc(innerfunc(arg1), arg2, arg3)
       ^^^^^^^^^^               ^^^^^^^^^^^^^


To select just the function's name, use |vin| (again, use |viN| to include the
'np.' part):

       *********
    np.outerfunc(innerfunc(arg1), arg2, arg3)
       ^^^^^^^^^^               ^^^^^^^^^^^^^


GRIPPING A TEXT OBJECT OR MOTION WITH A FUNCTION CALL

If you have tpope's excellent repeat.vim plugin, then the following command is
repeatable with the dot command (see |single-repeat|).

To prevent this mapping from being generated, and define your own, see
|g:surround_funk_create_mappings| below.

                                        *surround-funk#gs*
gs                     Grip (i.e wrap/encompass) any text object or motion with
                       with the function call in the unnamed register.


In the example below, with the cursor anywhere with a ^ symbol, you can do ysF
to 'yank the surrounding function call' (which is all the stuff with * above
it):

    *************               *************
    np.outerfunc(innerfunc(arg1), arg2, arg3)
    ^^^^^^^^^^^^^               ^^^^^^^^^^^^^


Then go to some other function call (or just a word) (the cursor can be
anywhere in this case):

    os.lonelyfunc(argA, argB)
    ^^^^^^^^^^^^^^^^^^^^^^^^^


And do gsiF or gsaF to 'grip/surround' the lonely function call with the yanked
one:

    *************                         *************
    np.outerfunc(os.lonelyfunc(argA, argB), arg2, arg3)
    ^


You could then move to a word:

    MeNext
    ^^^^^^


and grip/surround it with gsiw:

    *************      *************
    np.outerfunc(MeNext, arg2, arg3)
    ^


You could also grip a multi-line function call (again using gsiF or gsaF):

    **************      *******
    os.multi_line(argA(),
                    argB, argC) < anywhere on this line is fine too
    ^^^^^^^^^^^^^^  ^^^^^^^^^^^


To get:

    *************                    *
    np.outerfunc(os.multi_line(argA(),
                    argB, argC), arg2, arg3)
                               *************


SETTINGS

                                   *g:surround_funk_create_mappings*
By default |surround-funk| creates the above mappings. If you would rather it
didn't do this (for instance if you already have those key combinations mapped
to something else) you can turn them off with:

    let g:surround_funk_create_mappings = 0

And map them to something different with:

    nmap <your-map-here> <Plug>(<OperationToMap>)

For reference, the default mappings are as follows:

    " normal mode
    nmap dsf <Plug>(DeleteSurroundingFunction)
    nmap dsF <Plug>(DeleteSurroundingFUNCTION)
    nmap csf <Plug>(ChangeSurroundingFunction)
    nmap csF <Plug>(ChangeSurroundingFUNCTION)
    nmap ysf <Plug>(YankSurroundingFunction)
    nmap ysF <Plug>(YankSurroundingFUNCTION)

    " visual mode
    xmap <silent> af <Plug>(SelectWholeFunction)
    omap <silent> af <Plug>(SelectWholeFunction)
    xmap <silent> aF <Plug>(SelectWholeFUNCTION)
    omap <silent> aF <Plug>(SelectWholeFUNCTION)
    xmap <silent> if <Plug>(SelectWholeFunction)
    omap <silent> if <Plug>(SelectWholeFunction)
    xmap <silent> iF <Plug>(SelectWholeFUNCTION)
    omap <silent> iF <Plug>(SelectWholeFUNCTION)
    xmap <silent> an <Plug>(SelectFunctionName)
    omap <silent> an <Plug>(SelectFunctionName)
    xmap <silent> aN <Plug>(SelectFunctionNAME)
    omap <silent> aN <Plug>(SelectFunctionNAME)
    xmap <silent> in <Plug>(SelectFunctionName)
    omap <silent> in <Plug>(SelectFunctionName)
    xmap <silent> iN <Plug>(SelectFunctionNAME)
    omap <silent> iN <Plug>(SelectFunctionNAME)

    " operator pending mode
    nmap <silent> gs <Plug>(GripSurroundObject)
    vmap <silent> gs <Plug>(GripSurroundObject)

N.B. If you're worried about remapping the core vim command |gs|, done't be -
it literally does nothing.



                                *g:surround_funk_legal_func_name_chars*
By default the |surround-funk| plugin defines any vim word character
([0-9A-Za-z_]) and any period symbols as valid parts of a function's name.
These characters are used to find the function name when using the capitalised
(e.g. |dsF|, but not |dsf|) versions of the above commands. You can add to, or
remove from, these groups.

The default:

g:surround_funk_legal_func_name_chars = ['[0-9]', '[A-Z]', '[a-z]', '_', '\.']


    will match function names like:

          *********  *************  **************
    ...), pd.mean(), np2.my_func(), 8np.my._func(), ...
          ^^^^^^^^^  ^^^^^^^^^^^^^  ^^^^^^^^^^^^^^


    but would stop at characters not in the legal name set (e.g. @, #, /):

             ******         ******      **********
    ...), pd@mean(), np2.my#func(), 8np/my._func(), ...
             ^^^^^^         ^^^^^^      ^^^^^^^^^^


To make numbers illegal, and to introduce # and @ as legal characters, use:

g:surround_funk_legal_func_name_chars = ['[A-Z]', '[a-z]', '_', '\.', '#', '@']


    will match function names like:

          *********     **********   *************
    ...), pd.mean(), np2.my_func(), 8np.my._func(), ...
          ^^^^^^^^^     ^^^^^^^^^^   ^^^^^^^^^^^^^

          *********     **********      **********
    ...), pd@mean(), np2.my#func(), 8np/my._func(), ...
          ^^^^^^^^^     ^^^^^^^^^^      ^^^^^^^^^^
